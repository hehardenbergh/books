---
title: "gender hierarchy in fiction"
author: "Hannah Hardenbergh"
date: "3/28/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Whenever a
# file is read in or a folder is accessed in other chunks, I make sure that the
# correct working directory is called. originally, the authors organized their
# code with setwd() so that they didn't have to manually code all the file
# paths. Turns out that was confusing for my directories because of how I wanted
# to organize the authors' original data.

# as the author's readme says, you will need the functions and objects listed in
# this sourced file:

source("./books.data/hierarchy_adj.r")
```

```{r}

################################

# ------------------------
# THE HIERARCHY OF GENDER 
# ------------------------
# Author: Eve Kraicer and Dr. Andrew Piper
# Date: August 2018

################################

# This script runs all of the calculations for the paper.
# This includes interpreting the raw data, testing significance, and reporting values.
# This script also builds tables and figures.
# To run, change wd to a directory with nodes_ALL, edges_ALL, hierarchy_metadata.csv, and hierarchy_adj.R 

# load libraries

library(epiR)
library(stats)
library(igraph)

library(dplyr)
library(bazar)
library(reshape2)
library(stringr)
library(splitstackshape)
library(rapport)

library(ggplot2)
library(RColorBrewer)
library(gt)
library(knitr)
library(kableExtra)

library(tidyverse)

```

```{r }

# unzip the folders nodes_ALL and edges_ALL.

unzip("./books.data/edges_ALL.zip")
unzip("./books.data/nodes_ALL.zip")

# get rid of all working directory calls. manually set path directories for each
# file read-in. when you get rid of it, just be careful about where you are
# trying to grab files from. sometimes they are in different places.


# dont know why this function is here. It makes numeric strings character
# strings, but why??? --> turning factor variables into numeric. You can't do it
# though because of the way that factors are shown internally in R.

# This function is probably used to turn factor variables into numeric. You
# can't do that by just going straight to numeric because of the way that
# factors are represented internally in R.

num_func  <- function(x){as.numeric(as.character(x))}

# ------------------------
# SECTION I: DATA
# ------------------------

# this function is used for figure 2- running a Rogan and Gladen's approach to
# testing for the true prevalence of how many women are included in the dataset.

epi_add  <- function(pos, tested, se, sp){
  epi  <- (epi.prev(pos, tested, se_2, sp_2)$tp[[1]])*.01
  add  <- num_func(round((tested*epi)-pos))
  return(add)
}

# 1: DATA & DATA PREP
# = = = = = = = = = = = 

# metadata. make sure the file path name is correct in your project.

metadata.df <- data.frame(read_csv('books.data/hierarchy_metadata.csv'))

# subset by works with main character identified and by women

meta_mc.df <- metadata.df[metadata.df$mc_calc == 'Y',]
meta_w.df  <- metadata.df[metadata.df$ag == 'F',]

# tokens, nodes and edges


# interesting that I don't have the tokens file... in the original data.
# What/Where is it? (Command-shift-f finds every place something is mentioned in
# the project...)

# tokens_files <- list.files('tokens_ALL')

nodes_list <- c('nodes_YA', 'nodes_NYT', 'nodes_MY', 'nodes_SF',
                'nodes_BS', 'nodes_ROM', 'nodes_PW')

edges_list <- c('edges_YA', 'edges_NYT', 'edges_MY', 'edges_SF', 
                'edges_BS', 'edges_ROM', 'edges_PW')
```

```{r }
# 1b: TABLE ONE
# - - - - - - - - 
# gather info for table 1

# originally, authors used nlevels() and levels() to access the number of genres
# there are to build dataframes. but you need a factor to do that. the variable
# metadata.df$genre is a character string. so, I keep this for loop to build
# data frames but I used a new object, called "genre_levels".

genre_levels <- unique(metadata.df$genre)

files <- list.files('books.data/nodes_ALL')

data_info <- NULL
for (i in 1:length(genre_levels)){
  
  # find the data in the correct file path/working directory:
  
  meta_sub <- metadata.df[metadata.df$genre == genre_levels[i],]
  
  # Start to make columns with data
  
  titles  <- files[files %in% meta_sub$ID]
  author <- str_split_fixed(titles, "_", 3)
  no_authors <- length(unique(author[,2]))
  genre <- genre_levels[i]
  novels <- length(titles)
  perc_w <- (length(which(titles %in% meta_w.df$ID))/novels)*100
  
  # bind for a dataframe
  
  temp_info <- data.frame(cbind(genre, novels, no_authors, perc_w))
  data_info <- data.frame(rbind(data_info, temp_info))
}

# build and order table 1 

table_1 <- data_info[order(num_func(data_info$perc_w)),]

# make it pretty: column names, round percentages, etc. using gt().

table_1_tidy <- table_1 %>% 
  rename("code" = "genre") %>% 
  mutate(genre = c("Science Fiction",
                   "Prizewinners",
                   "Bestsellers",
                   "NYT Reviewed",
                   "Mystery",
                   "Young Adult",
                   "Romance"))


table_1_tidy %>%
  mutate(perc_w = as.numeric(as.character(perc_w))) %>% 
  gt() %>%
  cols_move_to_start(columns = vars(genre)) %>%
  cols_label(code = "Code", 
             novels = "Novels",
             no_authors = "# Authors",
             perc_w = "% Women Authors",
             genre = "Genre") %>% 
  fmt_number(columns = vars(perc_w), decimals = 2)


```


```{r }

# 1c: FIGURE ONE
# - - - - - - - - 

# DATA
# calculates the mentions for each character by rank position 

# run twice turning off / on condition
# once on all works (mentions) 
# once on only works with main character identified by gender (mentions_sub)

mentions <- NULL

# mentions_sub <- NULL

# set working directory to where the data lives.

files <- list.files('./books.data/nodes_ALL')

for(j in 1:length(files)){
  work  <- files[j]
  nodes <- data.frame(read_csv(paste0('books.data/nodes_ALL/', (files[j]))))

  # only pull mentions
  
  m_counts <- data.frame(nodes[,2]) 
  
  # add columns
  
  extra <- as.data.frame(matrix(c(rep.int(NA,length(200))),nrow=200))
  
  #give same column names
  
  colnames(extra) <- colnames(m_counts) 
  
  #bind
  
  mentions_bind <- rbind(m_counts, extra) 
  mentions <- cbind(mentions, mentions_bind[1:150,])
  
  # mentions_sub <- cbind(mentions_sub, mentions_bind[1:150,])
  # }
}

# count up sums for each rank position for both cases 
rank_m <- NULL
rank_m_sub <- NULL

for (i in 1:nrow(mentions)){
  mean <- mean(num_func(mentions[i,]), na.rm=TRUE)
  sum <- sum(mentions[i,], na.rm=TRUE)
  log_sum <- log(sum)
  rank <- i
  temp <- data.frame(cbind(rank,mean,sum,log_sum))
  rank_m <- data.frame(rbind(rank_m,temp))
}

# for (i in 1:nrow(mentions_sub)){
#   mean <- mean(num_func(mentions_sub[i,]), na.rm=TRUE)
#   sum <- sum(mentions_sub[i,], na.rm=TRUE)
#   log_sum <- log(sum)
#   rank <- i
#   temp <- data.frame(cbind(rank,mean,sum,log_sum))
#   rank_m_sub <- data.frame(rbind(rank_m_sub,temp))
# }

# BUILD  

# run on all works 

ggplot(data=rank_m, aes(x=rank, y=mean)) +
  geom_point()+
  ggtitle("Mean Mentions by Rank")+
  labs(x="Character Rank by Mentions", y="Mean Mentions")+
  theme_bw()+
  geom_vline(xintercept = 20, linetype = "dashed") +
  theme(plot.title = element_text(size = 13, family = "Times New Roman", face = "bold"),
        text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(face="bold"),
        axis.text.x=element_text(size = 11))

```


```{r }

# 1d: FIGURE TWO
# - - - - - - - - 

# DATA
# calculates raw counts of M/ W/ ? by rank position 

files <- list.files('./books.data/nodes_ALL')

# run four times turning off / on condition
# once on all works (raw) 
# once on only works with main character identified by gender (raw_sub)
# once on all works by women (raw_w) 
# once on only works by women with main character identified by gender (raw_sub_w)

# what you should do is make a vector with accurate dimensions if you know it,
# with NA's. but the authors just create objects with empty space to use later
# using NULL. 

raw <- NULL
raw_sub <- NULL
raw_w  <- NULL
raw_sub_w <- NULL

for(i in 1:length(files)){ 
  work  <- files[i]
  
  # only files where top pair was calculated 
  
  if (work %in% meta_mc.df$ID){
    
    # only files written by women authors 
    
    if (work %in% meta_w.df$ID){
      
      nodes <- data.frame(read_csv(paste0('books.data/nodes_ALL/', (files[i]))))
      genders <- data.frame(nodes[,3]) 
      
      # add columns to cbind different books 
      
      extra <- as.data.frame(matrix(c(rep.int(NA,length(200))),nrow=200)) 
      colnames(extra) <- colnames(genders)
      genders_bind <- rbind(genders, extra) 
      
      raw <- data.frame(cbind(raw, genders_bind[1:150,]))
      raw_sub <- data.frame(cbind(raw_sub, genders_bind[1:150,]))
      raw_w <- data.frame(cbind(raw_w, genders_bind[1:150,]))
      raw_sub_w  <- data.frame(cbind(raw_sub_w, genders_bind[1:150,]))
    }
  }
}

# clean vectors to normalize factors --> characters. This function will make
# gender identifiers. It does so by using gsub(), which replaces the numbers 1,
# 2, or 3 with 'M', 'F', or '?'.

clean_func  <- function(df){
  v <- df[,1]
  clean <- gsub(3, 'M', v)
  clean <- gsub(2, 'F', clean)
  clean <- gsub(1, '?', clean)
  return(clean)
}

raw[,1] <- clean_func(raw)
raw_sub[,1] <- clean_func(raw_sub)
raw_w[,1] <- clean_func(raw_w)
raw_sub_w[,1] <- clean_func(raw_sub_w)

# count up sums for each rank position

gender_id <- unique(raw[i])


rank_func  <- function(x){
  ranks <- NULL

  for (i in 1:nrow(x)){
    
    wr <- length(which(x[i,] == 'F')) # how many women
    mr <- length(which(x[i,] == 'M')) # how many men
    q  <- length(which(x[i,] == '?')) # how many unknown
    all <- mr + wr + q
    
    # adjust women and men 
    
    women  <- wr + epi_add(wr,
                           all,
                           se_2, 
                           sp_2)
    men  <- mr + epi_add(mr,
                         all,
                         se_2m,
                         se_2m)
    temp <- data.frame(women,
                       men,
                       q,
                       all) 
    #cbind for storage
    ranks <-data.frame(rbind(ranks,
                             temp))
  }
  
  ranks$rank <- 1:150
  ranks$cumulative_q  <- cumsum(ranks$q)/cumsum(ranks$all)
  return(ranks)
}

# here, the code is using the rank_func function that the authors create in
# hierarchy_adj.r, which is sourced at the beginning of this code. It makes the
# estimates for true prevalence tests that validate that some gender assignments
# in books are inaccurate. as in, on page 8 of the paper when authors discuss
# the proportions of accurately assigned and inaccurately assigned gender
# identifiers (male, female, or unknown.) Basically, this means that if there is
# a higher sensitivity rate for one gender, that means they have been assigned
# more accurately. when men have this higher rate, it accounts for the
# possibility of women being undercounted in the dataset after they have
# assigned gender identifiers manually.

# in order to run properly, apparent prevalence can't be less than (1 - Sp),
# otherwise the estimate of true prevalance will be "invalid".

ranks_all <- rank_func(raw)
ranks_sub  <- rank_func(raw_sub)
ranks_w  <- rank_func(raw_w)                   
ranks_sub_w  <- rank_func(raw_sub_w)   

# basic counts by subsets
# how many unknown overall?

perc_unknown10 <- sum(ranks_all$q[1:10])/sum(ranks_all$all[1:10])
perc_unknown20 <- sum(ranks_all$q[1:20])/sum(ranks_all$all[1:20])

# BUILD 
# run on all works

figure_2 <- ggplot(data=ranks_all, aes(x = rank, y = cumulative_q)) +
  geom_line()+
  ggtitle("% Unassigned Characters by Mentions Rank")+
  labs(x = "Character Rank by Mentions", 
       y = "Cumulative Percent Unassigned")+
  theme_bw() + 
  geom_vline(xintercept = 20, linetype = "dashed") + 
  theme(plot.title = element_text(size = 13, 
                                  family = "Times New Roman", 
                                  face = "bold"),
        text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(face="bold"),
        axis.text.x = element_text(size = 11))

figure_2

```


```{r }
# ------------------------
# SECTION II: VISIBILITY
# ------------------------

# bootstrapper 
# x is column on df to be sampled, y is df

boot_func <- function(x,y){
  sample <- as.character(sample(x, nrow(y), replace = TRUE))
  return(sample)
}

# adjustments
# for all
epi_func <- function(vector,w,m,q,se,sp){
  pos <- length(which(as.character(vector) == w))
  tested <- length(which(as.character(vector) == w | as.character(vector) == m | as.character(vector) == q)) 
  
  epi <- epi.prev(pos, tested, se, sp)
  adj_perc <- epi$tp[[1]]*.01
  adj_add <- round((tested*adj_perc)-pos)
  return(adj_add)
}

# for main chars
epi_func2 <- function(vector,w,m,se,sp){
  pos <- length(which(as.character(vector) == w))
  tested <- length(which(as.character(vector) == w | as.character(vector) == m)) # original sample set 
  
  epi <- epi.prev(pos, tested, se, sp)
  
  # find percentage increase of women for true prevalence of women as main character
  
  adj_perc <- epi$tp[[1]]*.01
  # how many more women is that? 
  adj_add <- round((tested*adj_perc)-pos)
  return(adj_add)
}
```


```{r }

# 1: TOP 20 & ALL 
# = = = = = = = = = 

# build master table with genders of top pairs from each document

# run twice for conditionals 
# once for all 
# once for only characters in the top twnety 

chars_all  <- NULL
chars_20 <- NULL

for (i in 1:nlevels(metadata.df$genre)){
  files <- list.files('./books.data/nodes_ALL')
  
  #loop through each file
  
  meta_sub <- metadata.df[metadata.df$genre == levels(metadata.df$genre)[i],]
  titles  <- files[files %in% meta_sub$ID]
  
  # loop through each file
  
  chars <- NULL
  for(j in 1:length(titles)){ 
    work <- titles[j]
    nodes <- data.frame(read_csv(paste0('/books.data/nodes_ALL/', (titles[j]))))

    
    # genders  <- as.character(nodes[,3])
    # for 20 chars run these lines 
    # make sure work has 20 chars
    
    if (nrow(nodes) >= 20){
      genders <- as.character(nodes[1:20,3])
    } else {
      genders <- as.character(nodes[,3])}
    ag <- as.character(metadata.df$ag[(which(metadata.df$ID %in% work))])
    genre <- levels(metadata.df$genre)[i]
    temp_chars <- data.frame(cbind(work,genders,ag,genre))
    chars <- data.frame(rbind(temp_chars,chars))
  }
  chars_20  <- data.frame(rbind(chars_20, chars))
  
  # chars_all <- data.frame(rbind(chars_all, chars))
}
```





```{r }
# 1a: ADJUSTMENTS
# - - - - - - - - - 

# how many M / ? need to be replaced with Fs?

men_rep2  <- epi_func(chars_20$genders, 'M', 'F', '?', se_2m, sp_2m)
q_rep2  <- (epi_func(chars_20$genders, 'F', 'M', '?', se_2, sp_2))-abs(men_rep2)

# randomly replace M 

rep_m20 <- sample(which(chars_20$gender == 'M'), men_rep2)
chars_20$adj_all <- replace(as.character(chars_20$gender), rep_m20, 'F')

# randomly replace ?

rep_q20 <- sample(which(chars_20$adj_all == '?'), q_rep2)
chars_20$adj_all <- replace(as.character(chars_20$adj_all), rep_q20, 'F')


# BOOTSTRAP 
# calculate the percentage of 'F' with bootstrapping 

# boot_chars_20 <- vector()
boot_chars_all  <- vector()
for (j in 1:10000){  
  sample <- boot_func(chars_20$adj_all, chars_20)
  # sample  <- boot_func(chars_all$adj_all, chars_all)
  f_perc <- length(which(sample == 'F'))/length(sample)
  boot_chars_20[j] <- f_perc
  # boot_chars_all[j] <- f_perc
}
```

```{r }
# 1b: REPORTED VALUES
# - - - - - - - - - - 
length(which(chars_20$genders == 'F')) # raw women
length(which(chars_20$adj_all == 'F')) # adjusted women 
length(which(chars_20$adj_all == 'F')) / nrow(chars_20) # % women 
mean(boot_chars_20) # bootstrap mean - top 20 
mean(boot_chars_all) # bootstrap mean - all 

# by genre and ag 

chars_func  <- function(x){
  results <- NULL
  for (i in 1:nlevels(x)){
    sub <- chars_20[which(as.character(x) == levels(x)[i]),]
    genre <- levels(x)[i]
    f <- vector()
    for (j in 1:10000){  
      sample <- boot_func(sub$adj_all, sub)
      f[j] <- length(which(sample == 'F'))
    }
    all  <- nrow(sub)
    temp <- data.frame(cbind('f'= mean(f), 'all'= all, genre))
    results <- data.frame(rbind(results,temp))
  }
  results$f_perc  <- num_func(results$f)/num_func(results$all)
  return(results)
}

# by genre and author gender 

boot_chars_genre <- chars_func(chars_20$genre)

# remove romance

chars_20xROM <- chars_20[which(chars_20$genre != 'ROM'),]
boot_chars_ag <- chars_func(chars_20xROM$ag)
boot_chars_ag_wROM <- chars_func(chars_20$ag)
```


```{r }
# 1d: SIGNIFICANCE TESTING
# - - - - - - - - - - - - - 
chisq_20  <- t(data.frame(cbind('women'=num_func(boot_chars_genre$f), 'all'=num_func(boot_chars_genre$all))))
chisq.test(chisq_20)

chisq_20_ag  <- t(data.frame(cbind('women'=num_func(boot_chars_ag$f[1:2]), 'all'=num_func(boot_chars_ag$all[1:2]))))
chisq.test(chisq_20_ag)
fisher.test(chisq_20_ag)

# 1e: TABLE TWO
# - - - - - - - - 
table_2  <- data.frame(cbind('genre'=as.character(boot_chars_genre$genre), 'percent_w'=num_func(boot_chars_genre$f_perc)*100))
table_2 <- table_2[order(num_func(table_2$percent_w)),]
```


```{r }

# 1f: FIGURES THREE & FOUR
# - - - - - - - - - - - - -

# DATA 
# from ranks_sub, update the first and second character based on perspective calcs

ranks_sub[1,1:2]  <- c(623, 617)
ranks_sub[2,1:2]  <- c(470, 768)
ranks_sub_w[1,1:2]  <- c(321,194)
ranks_sub_w[2,1:2]  <- c(191,324)

# get correct percentages of women 

ranks_sub$perc_w  <- ranks_sub$w/ranks_sub$all
ranks_sub_w$perc_w  <- ranks_sub_w$w/ranks_sub_w$all

# BUILD 
# figure 3 
# uses only works with main character identified 

figure_3 <- ggplot(data=ranks_sub, aes(rank)) + 
  geom_line(aes(y = women, colour = "Women")) + 
  geom_line(aes(y = men, colour = "Men")) +
  scale_color_manual(values=c("darkorange2", "mediumpurple4")) +
  ggtitle("Men and Women by Rank Position (All Authors)")+
  labs(x="Rank of Character", y="") +
  labs(color="Character Gender") +
  theme_bw() +
  theme(plot.title = element_text(size = 13, family = "Times New Roman", face = "bold"),
        text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(face="bold"),
        axis.text.x=element_text(size = 11)) +
  geom_vline(xintercept = 20, linetype = "dashed") 

# figure 4 

figure_4 <- ggplot(data=ranks_sub_w, aes(rank)) + 
  geom_line(aes(y = women, colour = "Women")) + 
  geom_line(aes(y = men, colour = "Men")) +
  scale_color_manual(values=c("darkorange2", "mediumpurple4")) +
  ggtitle("Men and Women by Rank Position (Women Authors)")+
  labs(x="Rank of Character", y="") +
  labs(color="Character Gender") +
  theme_bw() +
  theme(plot.title = element_text(size = 13, family = "Times New Roman", face = "bold"),
        text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(face="bold"),
        axis.text.x=element_text(size = 11)) +
  geom_vline(xintercept = 20, linetype = "dashed") 

```


```{r }
# 2: MAIN CHARACTER & TOP PAIRS
# = = = = = = = = = = = = = = = = = = 

# 2a: DATA PREP
# - - - - - - - -

# build master table with genders of top pairs from each document 

files <- list.files('nodes_ALL')
token_files  <- list.files('tokens_ALL')
top_chars2 <- NULL

#loop through each file

for(i in 1:length(files)){ 
  setwd('~/Desktop/hierarchy/hierarchy_data/nodes_ALL')
  print(i)
  work <- files[i]
  genre <- as.character(metadata.df$genre[(which(metadata.df$ID %in% work))])
  pov  <- as.character(metadata.df$pov[(which(metadata.df$ID %in% work))])
  ag <- as.character(metadata.df$ag[(which(metadata.df$ID %in% work))])
  nodes <- data.frame(read.csv(work))
  if (pov == '3p'){
    first <- as.character(nodes[1,3])
  }
  else if (pov == '1p'){
    setwd('~/Desktop/hierarchy/hierarchy_data/tokens_ALL')
    if (work %in% token_files){
      tokens <- read.csv(work, sep = ',')
      dep_null <- NULL
      for (i in 2:nlevels(factor(tokens$characterId))){
        sub <- tokens[factor(tokens$characterId) == levels(factor(tokens$characterId))[i],]
        if (nrow(sub) > 30){
          char_name <- as.character(sub$lemma)[1]
          charID <- sub$characterId[1]
          no_occurs <- nrow(sub)
          subj_occurs  <-  length(sub$deprel[sub$deprel == "null"])
          subj_ratio <- subj_occurs/no_occurs
          subj_adj_ratio <- log(subj_occurs)/log(no_occurs)
          gender <- num_func(sub$characterGender)[1]
          temp <- data.frame(char_name, charID, no_occurs, subj_ratio, subj_adj_ratio, gender)
          dep_null <- rbind(dep_null, temp)
        }
      }
      if (is.null(dep_null)) {dep_null$gender  <- 'error_1'} else {
        dep_null <- dep_null[order(-dep_null$subj_adj_ratio),]
        # insert rule on removing chars named Mr. or Mrs.
        remove <- which(as.character(dep_null$char_name) == "Mr." & as.character(dep_null$char_name) == "Mrs." & as.character(dep_null$char_name) == "Ms.")
        if (length(remove) > 0){
          dep_null <- dep_null[-remove, ]
        }
      } 
      first  <- dep_null$gender[1]
    } else {
      first  <- 'error_2'
    }
  }
  second <- as.character(nodes[2,3])
  temp_pairs <- data.frame(cbind(work,first,second,ag,genre,pov))
  top_chars2 <- data.frame(rbind(temp_pairs,top_chars2))
}
```


```{r }

# 2b: ADJUSTMENTS
# - - - - - - - - -

# calculate how many to add based on validation 

adj_3p <- epi_func(top_chars2$first, 'F', 'M', se_1, sp_1)
adj_1p <- epi_func(top_chars2$first, 1, 2, se_1b, sp_1b)
all_adj <- epi_func(top_chars2$second, 'F', 'M', se_1, sp_1)

# replace protagonists in 3p books

rep_first <- sample(which(top_chars2$first == 'M'), adj_3p)
top_chars2$adj_first <- replace(as.character(top_chars2$first), rep_first, 'F')

# for protagonists in 1p books 

rep_firstb <- sample(which(top_chars2$first == 2), adj_1p)
top_chars2$adj_first <- replace(as.character(top_chars2$adj_first), rep_firstb, 1)

# change all indicators from numeric --> characters 

top_chars2$first  <- gsub(1, 'F', top_chars2$first)
top_chars2$first  <- gsub(2, 'M', top_chars2$first)
top_chars2$adj_first  <- gsub(1, 'F', top_chars2$adj_first)
top_chars2$adj_first  <- gsub(2, 'M', top_chars2$adj_first)

# replace

rep_second <- sample(which(top_chars2$second == 'M'), all_adj)
top_chars2$adj_second <- replace(as.character(top_chars2$second), rep_second, 'F')

# clean all errors & subset

top_chars3  <- top_chars2[which(top_chars2$adj_first != 'error_M'),]
top_chars3  <- top_chars3[which(top_chars3$adj_first != 0),]
top_chars_1p  <- top_chars3[top_chars3$pov == '1p',]
top_chars_3p  <- top_chars3[top_chars3$pov == '3p',]

# calculate top pairs by genre and author gender 

tp_func  <- function(x,y){
  results <- NULL
  for (i in 1:nlevels(x)){
    sub <- top_chars3[which(as.character(x) == levels(x)[i]),]
    sub  <- sub[sub$genre != y,]
    group <- levels(x)[i]
    titles <- nrow(sub)
    temp  <- NULL
    for (i in 1:1000){
      # shuffle second char column
      sub$sec_samp <- sample(sub$adj_second, nrow(sub))
      sub$adj_tp  <- as.character(paste(sub$adj_first, sub$sec_samp, sep=''))
      sample <- boot_func(sub$adj_tp, sub)
      f  <- length(which(sample == 'FF'|sample == 'FM'))
      m  <- length(which(sample == 'MM'|sample == 'MF'))
      mm <- length(which(sample == 'MM'))
      ff <- length(which(sample == 'FF'))
      f_perc <- f/length(sample)
      m_perc  <- m/length(sample)
      mm_perc <- mm/length(sample)
      ff_perc <- ff/length(sample)
      mm_m  <- mm/m
      ff_f  <- ff/f
      vectors  <- data.frame(cbind(f,m,mm,ff,mm_m,ff_f, m_perc,f_perc,mm_perc,ff_perc))
      temp  <- rbind(temp,vectors)
    }
    
    mean_f <- mean(temp$f)
    mean_m <- mean(temp$m)
    mean_mm  <- mean(temp$mm)
    mean_ff  <- mean(temp$ff)
    mean_f_perc <- mean(temp$f_perc) 
    mean_m_perc <- mean(temp$m_perc)
    mean_ff_perc <- mean(temp$ff_perc)
    mean_mm_perc <- mean(temp$mm_perc)
    mean_ff_f  <- mean(temp$ff_f)
    mean_mm_m  <- mean(temp$mm_m)
    temp_tp <- data.frame(cbind(titles, group, mean_f, mean_m, mean_mm, mean_ff, 
                                mean_m_perc, mean_f_perc, mean_mm_perc, mean_ff_perc,
                                mean_ff_f, mean_mm_m))
    
    results <- data.frame(rbind(results, temp_tp))
  }
  return(results)
}

boot_tp_genre  <- tp_func(top_chars3$genre, 'NA')
boot_tp_ag  <- tp_func(top_chars3$ag, 'ROM')
```


```{r }
# 2c: TABLE 3 & 4
# - - - - - - - -  

table_3 <- data.frame(cbind('women'=num_func(boot_tp_genre$mean_f),
                            'perc_women'=num_func(boot_tp_genre$mean_f_perc)),
                      row.names = boot_tp_genre$group)

table_4  <- data.frame(cbind('genre'=as.character(boot_tp_genre$group), 
                        'perc_same_gender'=(num_func(boot_tp_genre$mean_ff) + num_func(boot_tp_genre$mean_mm))/num_func(boot_tp_genre$titles),
                             'ratio'=num_func(boot_tp_genre$mean_mm)/num_func(boot_tp_genre$mean_ff)))

table_4 <- table_4[order(num_func(table_4$ratio)),]

# 2d: REPORTED VALUES
# requires boot_func 
# - - - - - - - - - - 

# empty vectors 
boot_mc  <- vector()
boot_mc_1p <- vector()
boot_mc_3p  <- vector()

# all main characters

for (i in 1:10000){
  sample <- boot_func(top_chars3$adj_first, top_chars3)
  sample_perc <- length(which(sample == 'F'))/length(sample)
  boot_mc[i]  <- sample_perc
}
mean_mc  <- mean(boot_mc)

# 1p main characters (homodiegetic)

for (i in 1:10000){
  sample <- boot_func(top_chars_1p$adj_first, top_chars_1p)
  sample_perc <- length(which(sample == 'F'))/length(sample)
  boot_mc_1p[i]  <- sample_perc
}
mean_mc_1p  <- mean(boot_mc_1p)

# 3p main character (heterodiegetic)

for (i in 1:10000){
  sample <- boot_func(top_chars_3p$adj_first, top_chars_3p)
  sample_perc <- length(which(sample == 'F'))/length(sample)
  boot_mc_3p[i]  <- sample_perc
}
mean_mc_3p  <- mean(boot_mc_3p)

# second character

boot_sc  <- vector()
for (i in 1:10000){
  sample <- boot_func(top_chars3$adj_second, top_chars3)
  sample_perc <- length(which(sample == 'F'))/length(sample)
  boot_sc[i]  <- sample_perc
}
mean_sc  <- mean(boot_sc)

# second character in books by women 

boot_sc_w  <-  vector()
for (i in 1:10000){
  sub  <- top_chars3[top_chars3$ag == 'F',]
  sample <- boot_func(sub$adj_second, sub)
  sample_perc <- length(which(sample == 'F'))/length(sample)
  boot_sc_w[i]  <- sample_perc
}
mean_sc_w  <- mean(boot_sc_w)

# how many ff given f and mm given m? 

ff_f <- sum(num_func(boot_tp_genre$mean_ff))/sum(num_func(boot_tp_genre$mean_f))
mm_m  <- sum(num_func(boot_tp_genre$mean_mm))/sum(num_func(boot_tp_genre$mean_m))

# for author gender
# how many for each by women 

ff_pairs_w <- num_func(boot_tp_ag$mean_ff[1])
mm_pairs_w <- num_func(boot_tp_ag$mean_mm[1])
# by men 
ff_pairs_m <- num_func(boot_tp_ag$mean_ff[2])
mm_pairs_m <- num_func(boot_tp_ag$mean_mm[2])

# 2e: SIGNIFICANCE TESTING
# - - - - - - - - - - - - - 

# by genre

chsq_mc <- t(cbind(num_func(boot_tp_genre$mean_f), (num_func(boot_tp_genre$title))))[,1:7]
chisq.test(chsq_mc) 

# bu author gender 

chsq_mc_ag  <- t(cbind(num_func(boot_tp_ag$mean_f[1:2]), (num_func(boot_tp_ag$title[1:2]))))
chisq.test(chsq_mc_ag)
fisher.test(chsq_mc_ag)

# mm/ff by genre 
chsq_tp <- t(cbind(num_func(boot_tp_genre$mean_mm), (num_func(boot_tp_genre$mean_ff))))[,1:7]
chisq.test(chsq_tp)
mm_pairs/ff_pairs

# top pairs by author gender 
ft_tp_ag_w  <- data.frame(c(ff_pairs_w,ff_pairs_w+mm_pairs_w), c(ff_pairs_m, ff_pairs_m+mm_pairs_m))
ft_tp_ag_m  <- data.frame(c(mm_pairs_m, mm_pairs_m+ff_pairs_m), c(mm_pairs_w,ff_pairs_w+mm_pairs_w))
fisher.test(ft_tp_ag_w)
fisher.test(ft_tp_ag_m)
sum(num_func(chsq_tp_ag))
```
